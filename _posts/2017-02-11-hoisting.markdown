---
layout: post
title:  "Hoisting"
date:   2017-01-29 09:55:21 -0800
categories: javascript
style: |
  .post-title {
    font-family: 'Playfair Display', serif;
    font-size: 45px;
  }
  .post-content p {
    font-family: 'Pontano Sans', sans-serif;
    font-size: 20px;
  }
  pre, code {
    background-color: #ffd7d7;
  }
---

It‚Äôs super tempting to look at JavaScript code and assume it executes in order top to bottom. That‚Äôs mostly true, but not always. That ‚Äúmostly‚Äù can lead to some pretty confusing behavior. It‚Äôs easy to dismiss inconsistencies in JavaScript code to the flexibility of the language, but there‚Äôs actually some pretty cool stuff going on. Unexpected execution order in your program is probably due to something called hoisting.

{% highlight javascript %}
thing = 4;
var thing;
console.log( thing );
{% endhighlight %}

What is that going to print?

Most people will guess `undefined`, but it‚Äôs actually going to print `4`. Why?

Because JS separates `var thing = 4` into `var thing` and `thing=4`. So think of it as happening like this:
{% highlight javascript %}
var thing;
thing=4;
console.log(thing);
{% endhighlight %}

What about here:

{% highlight javascript %}
console.log(thing);
var thing = 4;
{% endhighlight %}

`4`? Nope. It‚Äôs going to print `undefined`. It happens like this:

{% highlight javascript %}
var thing;
console.log(thing);
thing=4;
{% endhighlight %}

Variable and function declarations are hoisted or ‚Äúmoved‚Äù up from where there are to the very top on their scope. That last bit is important. Hoisting is per scope. So if the code in the examples above were inside a function, they would be hoisted to the top of the function body, but they wouldn‚Äôt be hoisted up to the top of the file. Also worth noting is that only the declarations are hoisted and the other logic is left in place. If hoisting changed the order of everything it would be absolute chaos and you wouldn‚Äôt know what what happening when. Not cool. 

Ok so now that we went over simple variables let‚Äôs talk functions. Function declarations are hoisted but function expressions are not.

{% highlight javascript %}
sayHello();
function sayHello() {
    console.log( greeting ); // undefined
    var greeting = "hi";
}
{% endhighlight %}

The code above will actually execute in this order:

{% highlight javascript %}
function sayHello() {
    var greeting;
    console.log( greeting ); // undefined because we haven‚Äôt assigned a value yet
    greeting = "hi";
}
sayHello();
{% endhighlight %}

But checkout what happens when it‚Äôs a function expression:

{% highlight javascript %}
sayHello(); // results in a TypeError
var sayHello = function printGreeting() {
    // ...
};
{% endhighlight %}

`sayHello` is hoisted and attached to the outside scope (probs the global scope here), so `sayHello` doesn‚Äôt cause a `ReferenceError`. But `sayHello` has no value yet so when you call it,  `sayHello`() is trying to call an undefined value which is why you get a `TypeError`.

So what if you have both functions and variables? What gets hoisted first? Functions are hoisted first, then variables come after. 

{% highlight javascript %}
sayHello(); 
var sayHello;
function sayHello() {
    console.log( "hi" );
}
sayHello = function() {
    console.log( "hello there" );
};
{% endhighlight %}

That prints "hi". Here‚Äôs what happened: 

{% highlight javascript %}
function sayHello() {
    console.log( "hi");
}
sayHello(); // prints "hi‚Äù
sayHello = function() {
    console.log( "hello there" );
};
{% endhighlight %}

`var sayHello` was ignored even though it came before `function sayHello()` because function declarations are hoisted before normal variables.

Be careful though because while duplicate `var` declarations like the one above are pretty much ignored, function declarations **do override** previous function declarations. Checkout this nightmare:

{% highlight javascript %}
sayHello(); 
function sayHello() {
    console.log( "hi");
}
var sayHello = function() {
    console.log( "hello there" );
};
function sayHello() {
    console.log( "This will print because it overrides the previous function declaration" );
}
{% endhighlight %}

What prints? `"This will print because it overrides the previous function declaration" `
So basically, do yourself a favor and don‚Äôt make duplicate functions in the same scope.  Hopefully this has been helpful and saves you a headache or two :)

üëã 

